{"version":3,"sources":["js/bundle.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtNA;AAAA","file":"../priv/static/js/app.js","sourcesContent":["\"use strict\";\n\nvar BEGINNING = \"-B-\";\nvar END = \"-E-\";\nvar PUNCTUATION = '!\"#$%\\'()*+,./:;<=>?@[\\\\]^_`{|}~';\n\nvar is_punctuation = function is_punctuation(char) {\n\treturn PUNCTUATION.includes(char);\n};\n\nvar buzzing = function buzzing(words) {\n\tvar keys = Object.keys(words);\n\treturn getWord(words, BEGINNING, randomInt(5, 20), [], keys).reverse().reduce(function (acc, el) {\n\t\tif (el === \"-E-\") return acc;\n\t\tif (is_punctuation(el)) return acc + el;\n\t\treturn acc + \" \" + el;\n\t});\n};\n\nvar getWord = function getWord(words, word, count, targetList, keys) {\n\t'use strict';\n\n\tvar nextWords = words[word];\n\n\tvar _word = function (nextWords) {\n\t\t// return random word if nextwords is none\n\t\t// or small random chance, no random chance, ben said its better\n\t\tif (!nextWords || nextWords.length === 0) {\n\t\t\t// optimize this\n\t\t\treturn keys[randomInt(0, keys.length)];\n\t\t}\n\t\treturn nextWords[randomInt(0, nextWords.length)];\n\t}(nextWords);\n\n\tif (count <= 0) {\n\t\t// we reached zero before END\n\t\t// change this so that it forces to find the next END\n\t\tconsole.log(\"reached end with count\", count);\n\n\t\t// we find an END\n\t\tconsole.log('word', word);\n\t\tif (nextWords.includes(END)) {\n\t\t\t// we just push it to targetlist and return\n\t\t\ttargetList.push(END);\n\t\t\treturn targetList;\n\t\t}\n\t\t// there is no end\n\t\t// we just push the current word\n\t\t// and continue with another recursion\n\t\ttargetList.push(_word);\n\t\ttargetList = getWord(words, _word, count - 1, targetList, keys);\n\t}\n\n\tif (_word === END) {\n\t\t// we reached end\n\t\tconsole.log(\"reached END prematurely\", count);\n\t\treturn targetList;\n\t}\n\n\ttargetList = getWord(words, _word, count - 1, targetList, keys);\n\ttargetList.push(_word);\n\treturn targetList;\n};\n\nvar randomInt = function randomInt(min, max) {\n\tmin = Math.ceil(min);\n\tmax = Math.floor(max);\n\treturn Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive\n};\n\nvar app = function app() {\n\n\t//const current = new DatArchive(window.location.origin);\n\t//let downloadPromise = current.download('/', { \"timeout\": 50000 });\n\n\t// elements\n\tvar buzzwords = document.getElementById('buzzword');\n\tvar like = document.getElementById('like');\n\tvar next = document.getElementById('next');\n\tvar info = document.getElementById('info');\n\tvar app = document.getElementById('app');\n\tvar gen_el = document.getElementById('generation');\n\tvar overlay = document.getElementById('overlay');\n\tvar b_word = document.getElementById('b-word-goes-here');\n\tvar name = document.getElementById('name');\n\tvar name_button = document.getElementById('send');\n\tvar generation = 0;\n\n\t/*fetch(\"generation.json\")\n \t.then((response) => {\n \t\tresponse.text()\n \t\t\t.then((text) => {\n \t\t\t\tconst _data = JSON.parse(text);\n \t\t\t\tif (_data.generation > 0) {\n \t\t\t\t\tgeneration = _data.generation;\n \t\t\t\t\tgen_el.textContent = \"This archive is \" + generation + \" modifications of the corpus away from the original.\"\n \t\t\t\t}\n \t\t\t});\n \t});*/\n\n\tvar stats = function stats(action) {\n\t\tfetch(\"/stats\", {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: { 'Content-Type': 'application/x-www-form-urlencoded' },\n\t\t\tbody: \"action=\" + encodeURIComponent(action)\n\t\t});\n\t};\n\n\tfetch(\"data.json\").then(function (response) {\n\t\tresponse.text().then(function (text) {\n\t\t\tvar words = JSON.parse(text);\n\n\t\t\tvar endcount = 0;\n\n\t\t\tfor (var key in words) {\n\t\t\t\tif (words.hasOwnProperty(key)) {\n\t\t\t\t\t//console.log(key, words[key]);\n\t\t\t\t\tif (words[key].includes(END)) {\n\t\t\t\t\t\tendcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\"found\", endcount, \"in\", Object.keys(words).length);\n\n\t\t\tvar bound_buzz = buzzing.bind(null, words);\n\t\t\tvar exchange = function exchange(_bound_buzz, _buzzwords) {\n\t\t\t\tstats(\"next\");\n\t\t\t\t// TODO maybe add a calculating thing here\n\t\t\t\t_buzzwords.textContent = bound_buzz();\n\t\t\t};\n\t\t\tbuzzwords.textContent = bound_buzz();\n\t\t\t// do all the init here\n\t\t\t//next.addEventListener('click', exchange.bind(null, bound_buzz, buzzwords));\n\t\t\t//next.classList.remove('disabled');\n\n\t\t\t// info\n\n\t\t\t/*info.addEventListener('click', () => {\n   \tapp.classList.toggle(\"open\");\n   \tinfo.classList.toggle(\"closed\");\n   });*/\n\n\t\t\tdocument.addEventListener('keyup', function (e) {\n\t\t\t\t// L = 76, N == 78\n\t\t\t\tif (e.keyCode !== 76 && e.keyCode !== 78) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// L aka like\n\t\t\t\tif (e.keyCode === 76) {\n\t\t\t\t\tvar fake_name = \"linz\";\n\t\t\t\t\tstats(\"like\");\n\t\t\t\t\tfetch(\"/like\", {\n\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/x-www-form-urlencoded' },\n\t\t\t\t\t\tbody: \"name=\" + encodeURIComponent(fake_name) + \"&phrase=\" + encodeURIComponent(buzzwords.textContent)\n\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\texchange(bound_buzz, buzzwords);\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// N aka next\n\t\t\t\texchange(bound_buzz, buzzwords);\n\t\t\t\treturn;\n\t\t\t});\n\n\t\t\t/*name_button.addEventListener('click', () => {\n   \tlet name_v = \"linz\";\n   \tname_button.textContent = \"Sending...\"\n   \tfetch(\"/like\",\n   {\n   method: \"POST\",\n   headers: {'Content-Type':'application/x-www-form-urlencoded'},\n   body: \"name=\" + encodeURIComponent(name_v) + \"&phrase=\" + encodeURIComponent(buzzwords.textContent)\n   })\n   \t\t.then(() => {\n   \t\t\tname_button.textContent = \"Sent :-)\"\n   \t\t\twindow.setTimeout(() => {\n   \t\t\t\tbuzzwords.textContent = bound_buzz();\n   \t\t\t\toverlay.style.display = \"none\";\n   \t\t\t\tname_button.textContent = \"Send\"\n   \t\t\t\tname.value = \"\";\n   \t\t\t}, 500);\n   \t\t});\n   });*/\n\n\t\t\t// test for DatArchive\n\n\t\t\tlike.classList.remove('disabled');\n\n\t\t\tlike.addEventListener('click', function () {\n\n\t\t\t\t// show overlay\n\t\t\t\tb_word.textContent = buzzwords.textContent;\n\t\t\t\toverlay.style.display = \"flex\";\n\t\t\t\t// ask nicley about name\n\n\t\t\t\tstats(\"like\");\n\n\t\t\t\t/*for (let i = 0; i < result.length -1; i++) {\n    \tif(words[result[i]]) {\n    \t\tif(i == result.length - 1) {\n    \t\t\twords[result[i]].push(END);\n    \t\t\tcontinue;\n    \t\t}\n    \t\twords[result[i]].push(result[i+1]);\n    \t}\n    }*/\n\t\t\t});\n\t\t});\n\t});\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", app);\n"]}